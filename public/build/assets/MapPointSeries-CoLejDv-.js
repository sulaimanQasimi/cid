import{m as b}from"./MapPolygonSeries-BDBclGeh.js";import{e as f,f as P,r as v}from"./Theme-Dgo0XspA.js";import{ac as B}from"./SerialChart-CAnqEg8j.js";class D extends b{constructor(){super(...arguments),Object.defineProperty(this,"_types",{enumerable:!0,configurable:!0,writable:!0,value:["Point","MultiPoint"]}),Object.defineProperty(this,"_lineChangedDp",{enumerable:!0,configurable:!0,writable:!0,value:void 0})}_afterNew(){this.fields.push("polygonId","lineId","longitude","latitude","fixed"),super._afterNew()}markDirtyProjection(){this.markDirty()}markDirtyValues(t){super.markDirtyValues(),t&&this._positionBullets(t)}processDataItem(t){super.processDataItem(t);let i=t.get("geometry");if(!i)i={type:"Point",coordinates:[t.get("longitude",0),t.get("latitude",0)]},t.set("geometry",i);else if(i.type=="Point"){const e=i.coordinates;e&&(t.set("longitude",e[0]),t.set("latitude",e[1]))}else if(i.type=="MultiPoint"){const e=i.coordinates;e&&e[0]&&(t.set("longitude",e[0][0]),t.set("latitude",e[0][1]))}this._addGeometry(i,this)}_makeBullets(t){t.bullets=[],this.bullets.each(i=>{const e=t.get("geometry");if(e){if(e.type=="Point")this._setBulletParent(this._makeBullet(t,i));else if(e.type="MultiPoint"){let o=0;f(e.coordinates,()=>{this._setBulletParent(this._makeBullet(t,i,o)),o++})}}})}_setBulletParent(t){if(t){const i=t.get("sprite"),e=this.chart;if(i&&e){const o=i.dataItem;o&&(o.get("fixed")?i.parent!=e.bulletsContainer&&e.bulletsContainer.children.moveValue(i):i.parent!=this.bulletsContainer&&this.bulletsContainer.children.moveValue(i))}}}_positionBullet(t){const i=t.get("sprite");if(i){const e=i.dataItem;if(e&&e.get("fixed"))return;const o=e.get("latitude"),s=e.get("longitude"),l=e.get("lineDataItem"),u=e.get("fixed"),r=this.chart;let a;if(l)a=l.get("mapLine");else{const n=e.get("lineId");n&&r&&r.series.each(g=>{if(g.isType("MapLineSeries")){let p=g.getDataItemById(n);p&&(e.set("lineDataItem",p),a=p.get("mapLine"))}})}this._lineChangedDp&&this._lineChangedDp.dispose(),a&&(this._lineChangedDp=a.events.on("linechanged",()=>{this._positionBullets(e)}));const m=e.get("polygonDataItem");let c;if(m)c=m.get("mapPolygon");else{const n=e.get("polygonId");n&&r&&r.series.each(g=>{if(g.isType("MapPolygonSeries")){let p=g.getDataItemById(n);p&&(e.set("polygonDataItem",p),c=p.get("mapPolygon"))}})}const d=e.get("positionOnLine");let h,y;if(c){let n=c.visualCentroid();h=[n.longitude,n.latitude],e.setRaw("longitude",n.longitude),e.setRaw("latitude",n.latitude)}else if(a&&P(d)){let n=a.positionToGeoPoint(d);if(h=[n.longitude,n.latitude],e.get("autoRotate",t.get("autoRotate"))&&r){const g=a.positionToGeoPoint(d-.002),p=a.positionToGeoPoint(d+.002),_=r.convert(g),I=r.convert(p);y=B(_,I)}e.setRaw("longitude",n.longitude),e.setRaw("latitude",n.latitude)}else if(P(s)&&P(o))h=[s,o];else{const n=e.get("geometry");if(n){if(n.type=="Point")this._positionBulletReal(t,n,n.coordinates,y);else if(n.type=="MultiPoint"){let g=t._index||0;h=n.coordinates[g]}}}!u&&h&&this._positionBulletReal(t,{type:"Point",coordinates:h},h,y)}}_positionBulletReal(t,i,e,o){const s=t.get("sprite"),l=this.chart;if(l){const u=l.get("projection"),r=l.getPrivate("geoPath"),a=s.dataItem,m=u(e);if(m){const d={x:m[0],y:m[1]};s.setAll(d),a.setRaw("point",d)}let c=!0;r(i)?this.get("clipFront")&&(c=!1):this.get("clipBack")&&(c=!1),s.setPrivate("visible",c),a.set("clipped",!c),a&&o!=null&&a.get("autoRotate",t.get("autoRotate"))&&s.set("rotation",o+a.get("autoRotateAngle",t.get("autoRotateAngle",0)))}}zoomToDataItem(t,i,e){const o=this.chart;if(o){const s=t.get("longitude",0),l=t.get("latitude",0);return e?o.zoomToGeoPoint({longitude:s,latitude:l},i,!0,void 0,-s,-l):o.zoomToGeoPoint({longitude:s,latitude:l},i,!0)}}zoomToDataItems(t,i){let e=null,o=null,s=null,l=null;if(f(t,u=>{const r=u.get("longitude",0),a=u.get("latitude",0);(e==null||e>r)&&(e=r),(o==null||o<r)&&(o=r),(s==null||s<a)&&(s=a),(l==null||l>a)&&(l=a)}),e!=null&&o!=null&&s!=null&&l!=null){const u=this.chart;if(u)return i?u.zoomToGeoBounds({left:e,right:o,top:s,bottom:l},void 0,-(e+(o-e)/2),-(s+(s-l)/2)):u.zoomToGeoBounds({left:e,right:o,top:s,bottom:l})}}disposeDataItem(t){const i=this.chart;i&&i.series.each(e=>{e.isType("MapLineSeries")&&f(e.dataItems,o=>{const s=o.get("pointsToConnect");s&&f(s,l=>{l==t&&(v(s,l),e.markDirtyValues(o))})})}),super.disposeDataItem(t)}_excludeDataItem(t){super._excludeDataItem(t);const i=t.bullets;i&&f(i,e=>{const o=e.get("sprite");o&&o.setPrivate("visible",!1)})}_unexcludeDataItem(t){super._unexcludeDataItem(t);const i=t.bullets;i&&f(i,e=>{const o=e.get("sprite");o&&o.setPrivate("visible",!0)})}_notIncludeDataItem(t){super._notIncludeDataItem(t);const i=t.bullets;i&&f(i,e=>{const o=e.get("sprite");o&&o.setPrivate("visible",!1)})}_unNotIncludeDataItem(t){super._unNotIncludeDataItem(t);const i=t.bullets;i&&f(i,e=>{const o=e.get("sprite");o&&o.setPrivate("visible",!0)})}}Object.defineProperty(D,"className",{enumerable:!0,configurable:!0,writable:!0,value:"MapPointSeries"});Object.defineProperty(D,"classNames",{enumerable:!0,configurable:!0,writable:!0,value:b.classNames.concat([D.className])});export{D as M};
