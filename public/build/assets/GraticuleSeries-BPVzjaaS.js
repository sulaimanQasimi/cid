import{b as U,n as M,A as W,c as B,s as G,d as P,e as D,f as I,r as x,h as L,i as S,j as N,k as Z,l as F,m as H}from"./MapPolygonSeries-BYjX0ZLu.js";import{f as R,z as ee,e as E}from"./Theme-Dgo0XspA.js";import{G as J,P as te,a9 as ne}from"./SerialChart-CAnqEg8j.js";function j(a,e,t){a=+a,e=+e,t=(i=arguments.length)<2?(e=a,a=0,1):i<3?1:+t;for(var n=-1,i=Math.max(0,Math.ceil((e-a)/t))|0,s=new Array(i);++n<i;)s[n]=a+n*t;return s}var V,X,A,C,_={sphere:M,point:M,lineStart:ie,lineEnd:M,polygonStart:M,polygonEnd:M};function ie(){_.point=se,_.lineEnd=re}function re(){_.point=_.lineEnd=M}function se(a,e){a*=x,e*=x,X=a,A=D(e),C=P(e),_.point=oe}function oe(a,e){a*=x,e*=x;var t=D(e),n=P(e),i=I(a-X),s=P(i),c=D(i),u=n*c,l=C*t-A*n*s,g=A*t+C*n*s;V.add(B(G(u*u+l*l),g)),X=a,A=t,C=n}function K(a){return V=new W,U(a,_),+V}var Y=[null,null],ae={type:"LineString",coordinates:Y};function le(a,e){return Y[0]=a,Y[1]=e,K(ae)}function q(a,e,t){var n=j(a,e-L,t).concat(e);return function(i){return n.map(function(s){return[i,s]})}}function $(a,e,t){var n=j(a,e-L,t).concat(e);return function(i){return n.map(function(s){return[s,i]})}}function ce(){var a,e,t,n,i,s,c,u,l=10,g=l,p=90,y=360,v,d,h,b,f=2.5;function o(){return{type:"MultiLineString",coordinates:m()}}function m(){return j(S(n/p)*p,t,p).map(h).concat(j(S(u/y)*y,c,y).map(b)).concat(j(S(e/l)*l,a,l).filter(function(r){return I(r%p)>L}).map(v)).concat(j(S(s/g)*g,i,g).filter(function(r){return I(r%y)>L}).map(d))}return o.lines=function(){return m().map(function(r){return{type:"LineString",coordinates:r}})},o.outline=function(){return{type:"Polygon",coordinates:[h(n).concat(b(c).slice(1),h(t).reverse().slice(1),b(u).reverse().slice(1))]}},o.extent=function(r){return arguments.length?o.extentMajor(r).extentMinor(r):o.extentMinor()},o.extentMajor=function(r){return arguments.length?(n=+r[0][0],t=+r[1][0],u=+r[0][1],c=+r[1][1],n>t&&(r=n,n=t,t=r),u>c&&(r=u,u=c,c=r),o.precision(f)):[[n,u],[t,c]]},o.extentMinor=function(r){return arguments.length?(e=+r[0][0],a=+r[1][0],s=+r[0][1],i=+r[1][1],e>a&&(r=e,e=a,a=r),s>i&&(r=s,s=i,i=r),o.precision(f)):[[e,s],[a,i]]},o.step=function(r){return arguments.length?o.stepMajor(r).stepMinor(r):o.stepMinor()},o.stepMajor=function(r){return arguments.length?(p=+r[0],y=+r[1],o):[p,y]},o.stepMinor=function(r){return arguments.length?(l=+r[0],g=+r[1],o):[l,g]},o.precision=function(r){return arguments.length?(f=+r,v=q(s,i,90),d=$(e,a,f),h=q(u,c,90),b=$(n,t,f),o):f},o.extentMajor([[-180,-90+L],[180,90-L]]).extentMinor([[-180,-80-L],[180,80+L]])}function ue(a,e){var t=a[0]*x,n=a[1]*x,i=e[0]*x,s=e[1]*x,c=P(n),u=D(n),l=P(s),g=D(s),p=c*P(t),y=c*D(t),v=l*P(i),d=l*D(i),h=2*Z(G(F(s-n)+c*l*F(i-t))),b=D(h),f=h?function(o){var m=D(o*=h)/b,r=D(h-o)/b,k=r*p+m*v,w=r*y+m*d,Q=r*u+m*g;return[B(w,k)*N,B(Q,G(k*k+w*w))*N]}:function(){return[t*N,n*N]};return f.distance=h,f}class O extends J{constructor(){super(...arguments),Object.defineProperty(this,"_projectionDirty",{enumerable:!0,configurable:!0,writable:!0,value:!1})}_beforeChanged(){if(super._beforeChanged(),this._projectionDirty||this.isDirty("geometry")||this.isDirty("precision")){const e=this.get("geometry");if(e){const n=this.getPrivate("series");if(n){const i=n.chart;if(i){const s=i.get("projection");let c=null;s&&s.clipAngle&&(c=s.clipAngle(),s.precision(this.get("precision",.5)));const u=this.dataItem,l=i.getPrivate("geoPath");if(l&&u)if(this._clear=!0,u.get("lineType",n.get("lineType"))=="straight"){const g=this.get("geometry");if(g){let p=g.coordinates;if(p){let y;g.type=="LineString"?y=[p]:g.type=="MultiLineString"&&(y=p),this.set("draw",v=>{for(let d=0;d<y.length;d++){let h=y[d];if(h.length>0){const b=h[0],f=i.convert({longitude:b[0],latitude:b[1]});v.lineTo(f.x,f.y);for(let o=0;o<h.length;o++){const m=h[o],r=i.convert({longitude:m[0],latitude:m[1]});v.lineTo(r.x,r.y)}}}})}}}else this.set("draw",g=>{s&&n.get("clipBack")===!1&&s.clipAngle(180),l.context(this._display),l(e),l.context(null),s&&s.clipAngle&&s.clipAngle(c)})}}}const t="linechanged";this.events.isEnabled(t)&&this.events.dispatch(t,{type:t,target:this})}}markDirtyProjection(){this.markDirty(),this._projectionDirty=!0}_clearDirty(){super._clearDirty(),this._projectionDirty=!1}_getTooltipPoint(){let e=this.get("tooltipX"),t=this.get("tooltipY"),n=0,i=0;if(R(e)&&(n=e),R(t)&&(i=t),e instanceof te){const s=this.positionToGeoPoint(e.value),c=this.getPrivate("series");if(c){const u=c.chart;if(u){const l=u.convert(s);n=l.x,i=l.y}}}return{x:n,y:i}}positionToGeoPoint(e){const t=this.get("geometry"),n=this.getPrivate("series"),i=n.chart,s=this.dataItem;if(t&&n&&i&&s){const c=s.get("lineType",n.get("lineType"));let u=K(t),l=0,g,p=0,y=0,v,d,h=t.coordinates;if(h){let b;t.type=="LineString"?b=[h]:t.type=="MultiLineString"&&(b=h);for(let f=0;f<b.length;f++){let o=b[f];if(o.length>1){for(let m=1;m<o.length;m++)if(v=o[m-1],d=o[m],p=l/u,g=le(v,d),l+=g,y=l/u,p<=e&&y>e){f=b.length;break}}else o.length==1&&(v=o[0],d=o[0],p=0,y=1)}if(v&&d){let f=(e-p)/(y-p),o;if(c=="straight"){let m=i.convert({longitude:v[0],latitude:v[1]}),r=i.convert({longitude:d[0],latitude:d[1]}),k=m.x+(r.x-m.x)*f,w=m.y+(r.y-m.y)*f;return i.invert({x:k,y:w})}else return o=ue(v,d)(f),{longitude:o[0],latitude:o[1]}}}}return{longitude:0,latitude:0}}}Object.defineProperty(O,"className",{enumerable:!0,configurable:!0,writable:!0,value:"MapLine"});Object.defineProperty(O,"classNames",{enumerable:!0,configurable:!0,writable:!0,value:J.classNames.concat([O.className])});class T extends H{constructor(){super(...arguments),Object.defineProperty(this,"mapLines",{enumerable:!0,configurable:!0,writable:!0,value:this.addDisposer(new ne(ee.new({}),()=>O._new(this._root,{},[this.mapLines.template])))}),Object.defineProperty(this,"_types",{enumerable:!0,configurable:!0,writable:!0,value:["LineString","MultiLineString"]})}_afterNew(){this.fields.push("lineType"),this._setRawDefault("lineTypeField","lineType"),super._afterNew()}makeMapLine(e){const t=this.children.push(this.mapLines.make());return t._setDataItem(e),this.mapLines.push(t),t}markDirtyProjection(){E(this.dataItems,e=>{let t=e.get("mapLine");t&&t.markDirtyProjection()})}_prepareChildren(){super._prepareChildren(),this.isDirty("stroke")&&this.mapLines.template.set("stroke",this.get("stroke"))}processDataItem(e){super.processDataItem(e);let t=e.get("mapLine");t||(t=this.makeMapLine(e)),this._handlePointsToConnect(e),e.on("pointsToConnect",()=>{this._handlePointsToConnect(e)}),e.set("mapLine",t),this._addGeometry(e.get("geometry"),this),t.setPrivate("series",this)}_handlePointsToConnect(e){const t=e.get("pointsToConnect");t&&(E(t,n=>{n.on("geometry",()=>{this.markDirtyValues(e)}),n.on("longitude",()=>{this.markDirtyValues(e)}),n.on("latitude",()=>{this.markDirtyValues(e)})}),this.markDirtyValues(e))}markDirtyValues(e){if(super.markDirtyValues(),e){const t=e.get("mapLine");if(t){const n=e.get("pointsToConnect");if(n){let i=[];E(n,c=>{const u=c.get("longitude"),l=c.get("latitude");if(u!=null&&l!=null)i.push([u,l]);else{const g=c.get("geometry");if(g){const p=g.coordinates;p&&i.push([p[0],p[1]])}}});let s={type:"LineString",coordinates:i};e.setRaw("geometry",s),t.set("geometry",s)}else t.set("geometry",e.get("geometry"))}}}disposeDataItem(e){super.disposeDataItem(e);const t=e.get("mapLine");t&&(this.mapLines.removeValue(t),t.dispose())}_excludeDataItem(e){super._excludeDataItem(e);const t=e.get("mapLine");t&&t.setPrivate("visible",!1)}_unexcludeDataItem(e){super._unexcludeDataItem(e);const t=e.get("mapLine");t&&t.setPrivate("visible",!0)}_notIncludeDataItem(e){super._notIncludeDataItem(e);const t=e.get("mapLine");t&&t.setPrivate("visible",!1)}_unNotIncludeDataItem(e){super._unNotIncludeDataItem(e);const t=e.get("mapLine");t&&t.setPrivate("visible",!0)}}Object.defineProperty(T,"className",{enumerable:!0,configurable:!0,writable:!0,value:"MapLineSeries"});Object.defineProperty(T,"classNames",{enumerable:!0,configurable:!0,writable:!0,value:H.classNames.concat([T.className])});class z extends T{constructor(){super(...arguments),Object.defineProperty(this,"_dataItem",{enumerable:!0,configurable:!0,writable:!0,value:this.makeDataItem({})})}_afterNew(){super._afterNew(),this.dataItems.push(this._dataItem),this._generate()}_updateChildren(){if(super._updateChildren(),this.isDirty("step")&&this._generate(),this.isDirty("clipExtent")&&this.get("clipExtent")){const e=this.chart;e&&e.events.on("geoboundschanged",()=>{this._generate()}),this._generate()}}_generate(){let e=ce();if(e){if(this.get("clipExtent")){const n=this.chart;if(n){const i=n.geoBounds();i&&e.extent([[i.left,i.bottom],[i.right,i.top]])}}const t=this.get("step",10);e.stepMinor([360,360]),e.stepMajor([t,t]),this._dataItem.set("geometry",e())}}}Object.defineProperty(z,"className",{enumerable:!0,configurable:!0,writable:!0,value:"GraticuleSeries"});Object.defineProperty(z,"classNames",{enumerable:!0,configurable:!0,writable:!0,value:T.classNames.concat([z.className])});export{z as G,O as M,T as a};
